{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,MAAM,MAAM,GAAG,QAAQ,CAAC;AACxB,MAAM,cAAc,GAAG,6BAA6B,CAAC,CAAC,kCAAkC;AACxF,MAAM,oBAAoB,GAAG,cAAc,CAAC;AAE5C,MAAM,eAAe,GAAG,IAAI,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;AAE3D,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC;IAC1B,GAAG;IACH,IAAI;IACJ,KAAK;IACL,IAAI;IACJ,IAAI;IACJ,SAAS;IACT,KAAK;IACL,IAAI;IACJ,IAAI;IACJ,KAAK;IACL,IAAI;IACJ,IAAI;IACJ,SAAS;IACT,KAAK;IACL,IAAI;IACJ,IAAI;IACJ,MAAM;IACN,IAAI;IACJ,MAAM;IACN,KAAK;IACL,IAAI;IACJ,MAAM;IACN,MAAM;IACN,MAAM;IACN,KAAK;IACL,IAAI;IACJ,IAAI;IACJ,MAAM;IACN,GAAG;IACH,QAAQ;IACR,KAAK;IACL,IAAI;IACJ,MAAM;IACN,MAAM;IACN,SAAS;IACT,KAAK;CACN,CAAC,CAAC;AAOH,MAAM,UAAU,SAAS,CACvB,KAAa,EACb,UAAuC,EAAE;IAEzC,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,IAAI,CAAyB,CAAC;IAE9B,MAAM,EAAE,UAAU,GAAG,WAAW,EAAE,MAAM,EAAE,GACxC,OAAO,OAAO,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC;QACnD,CAAC,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE;QACrB,CAAC,CAAC,OAAO,CAAC;IAEd,2BAA2B;IAC3B,OAAO,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,IAAI,EAAE;QACxC,MAAM,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;QAE9B,oCAAoC;QACpC,IAAI,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;YAC9B,MAAM,IAAI,KAAK,CAAC;SACjB;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,oBAAoB,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;gBACrD,iDAAiD;gBACjD,IACE,KAAK,GAAG,CAAC;oBACT,KAAK,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM;oBACnC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EACjB;oBACA,OAAO,CAAC,CAAC;iBACV;gBAED,sDAAsD;gBACtD,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;oBAC9D,OAAO,CAAC,CAAC;iBACV;gBAED,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,iBAAiB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC5D,CAAC,CAAC,CAAC;SACJ;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["const TOKENS = /\\S+|./g;\nconst IS_MANUAL_CASE = /\\p{Ll}(?=[\\p{Lu}])|\\.\\p{L}/u; // iPhone, example.com, U.N., etc.\nconst ALPHANUMERIC_PATTERN = /[\\p{L}\\d]+/gu;\n\nconst WORD_SEPARATORS = new Set([\"—\", \"–\", \"-\", \"―\", \"/\"]);\n\nconst SMALL_WORDS = new Set([\n  \"a\",\n  \"an\",\n  \"and\",\n  \"as\",\n  \"at\",\n  \"because\",\n  \"but\",\n  \"by\",\n  \"en\",\n  \"for\",\n  \"if\",\n  \"in\",\n  \"neither\",\n  \"nor\",\n  \"of\",\n  \"on\",\n  \"only\",\n  \"or\",\n  \"over\",\n  \"per\",\n  \"so\",\n  \"some\",\n  \"than\",\n  \"that\",\n  \"the\",\n  \"to\",\n  \"up\",\n  \"upon\",\n  \"v\",\n  \"versus\",\n  \"via\",\n  \"vs\",\n  \"when\",\n  \"with\",\n  \"without\",\n  \"yet\",\n]);\n\nexport interface Options {\n  smallWords?: Set<string>;\n  locale?: string | string[];\n}\n\nexport function titleCase(\n  input: string,\n  options: Options | string[] | string = {},\n) {\n  let result = \"\";\n  let m: RegExpExecArray | null;\n\n  const { smallWords = SMALL_WORDS, locale } =\n    typeof options === \"string\" || Array.isArray(options)\n      ? { locale: options }\n      : options;\n\n  // tslint:disable-next-line\n  while ((m = TOKENS.exec(input)) !== null) {\n    const { 0: token, index } = m;\n\n    // Ignore already capitalized words.\n    if (IS_MANUAL_CASE.test(token)) {\n      result += token;\n    } else {\n      result += token.replace(ALPHANUMERIC_PATTERN, (m, i) => {\n        // Ignore small words except at beginning or end.\n        if (\n          index > 0 &&\n          index + token.length < input.length &&\n          smallWords.has(m)\n        ) {\n          return m;\n        }\n\n        // Only capitalize words after a valid word separator.\n        if (i > 1 && !WORD_SEPARATORS.has(input.charAt(index + i - 1))) {\n          return m;\n        }\n\n        return m.charAt(0).toLocaleUpperCase(locale) + m.slice(1);\n      });\n    }\n  }\n\n  return result;\n}\n"]}